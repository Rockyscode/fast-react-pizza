1. You could define seclector funtions in the stateSilice file where you export reducer and actions and memoize them using the reselect library(best practice). Before this I used to create the selector function on the fly where they where needed.
   1.a => Now the selector funtion should always start with `get` like this

```javascript
export default cartSlice.reducer;

export const getUsername = (state) => state.user.username;

export const getCart = (state) => state.cart.cart;

export const getTotalCartQuantity = (state) =>
  state.cart.cart.reduce((sum, item) => sum + item.quantity, 0);

export const getTotalCartPrice = (state) =>
  state.cart.cart.reduce((sum, item) => sum + item.totalPrice, 0);

export const getCurrentQuantityById = (id) => (state) =>
  state.cart.cart.find((item) => item.pizzaId === id)?.quantity ?? 0;
```

Look at the last function where it needs an id and returns the selector function. We do that when we need some data to be used in the selecor function.

2. You can call an reducer in another reducer if you need using the stateSlice.

`caseReducer.<the slice you need>`

eg:

```javascript
decreaseItemQuantity: (state, action) => {
  // payload = pizzaId
  const item = state.cart.find((item) => item.pizzaId === action.payload);
  item.quantity--;
  item.totalPrice = item.quantity * item.unitPrice;

  if (item.quantity === 0) cartSlice.caseReducers.deleteItem(state, action);
};
```

3. You don't call the seclector function in the selector it is the job of the redux you just mention it the name which function do you want to call.

like this `const cart = useSelector(getCart);`

4. So now If we want to send some data to the selector function then we call another function see the example.

See here we have called the function directly
`const currentQuantity = useSelector(getCurrentQuantityById(id));`
But also look at the selector function

```javascript
export const getCurrentQuantityById = (id) => (state) =>
  state.cart.cart.find((item) => item.pizzaId === id)?.quantity ?? 0;
```

we did not call the selector function actually we called the function that takes the pizzaID and returns a selector function that redux will call if needed.

in summery we don't call selector function in the selector hook. It is the job of redux.

5. We can dipatch actions in the component using the useDispatch hook but it becomes tough to dipatch an action from an action or loader as we had to clearCart() from the createOrder action.

in Such cases we import the store and call the dispatch function in it with the clearCart() action.
like this `store.dispatch(clearCart());` but it disables some optimization of redux hence This should not be over done.

6. # What is createAsyncThunk and how does it work

`Suppose we want to fetch some data from an API and store it in our Redux state. We use the createAsyncThunk function to create a thunk action creator called fetchData. We pass a string ‘data/fetch’ as the first argument, and an async function as the second argument. The async function takes a payload and a thunkAPI as parameters, and uses the fetch method to make an API call with the payload. It returns a promise that resolves to the data, or rejects with an error.

We also use the createSlice function to create a slice of state called dataSlice. We pass an object with a name, an initialState, and an extraReducers field. The extraReducers field uses the bracket notation to handle the actions generated by the fetchData thunk. It defines three case reducers for the pending, fulfilled, and rejected actions, and updates the state accordingly.

We import the fetchData action creator and the dataSlice reducer in our app, and use the configureStore function to create a Redux store with the reducer. We also use the useDispatch and useSelector hooks to access the dispatch function and the state from the store.

In our component, we use the useEffect hook to dispatch the fetchData action creator with a payload when the component mounts. We also use the useSelector hook to get the data and the loading status from the state.

When we dispatch the fetchData action creator, it returns a thunk function that is passed to the Redux thunk middleware. The thunk function dispatches a pending action with a type ‘data/fetch/pending’ and a unique requestId. The pending action is handled by the dataSlice reducer, which sets the loading status to ‘pending’ and stores the requestId in the state.

The thunk function then runs the async function that we passed to the createAsyncThunk function. It makes the API call with the payload and waits for the response. If the response is successful, it dispatches a fulfilled action with a type ‘data/fetch/fulfilled’, a payload of the data, and the same requestId. The fulfilled action is handled by the dataSlice reducer, which sets the loading status to ‘idle’, stores the data in the state, and clears the requestId.

If the response is unsuccessful, it dispatches a rejected action with a type ‘data/fetch/rejected’, a payload of the error, and the same requestId. The rejected action is handled by the dataSlice reducer, which sets the loading status to ‘error’, stores the error in the state, and clears the requestId.

The thunk function also handles cancellation and aborting, by using the signal and the requestId from the thunkAPI. If the thunk function is cancelled or aborted, it dispatches a rejected action with a meta field that indicates the reason for the rejection.

This is how the createAsyncThunk function works from start to end.`
